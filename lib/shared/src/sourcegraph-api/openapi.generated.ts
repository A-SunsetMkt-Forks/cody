// @ts-nocheck
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    '/.api/agents': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['AgentService_retrieveAgents']
        put?: never
        post: operations['AgentService_createAgent']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/agents/{agent_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['AgentService_retrieveAgent']
        put?: never
        post?: never
        delete: operations['AgentService_removeAgent']
        options?: never
        head?: never
        patch: operations['AgentService_updateAgent']
        trace?: never
    }
    '/.api/agents/{agent_id}/connections': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post: operations['AgentService_createConnection']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/agents/{agent_id}/connections/{connection_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        delete: operations['AgentService_removeConnection']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/agents/{agent_id}/programs': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post: operations['AgentService_createProgram']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/agents/{agent_id}/programs/{program_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        delete: operations['AgentService_removeProgram']
        options?: never
        head?: never
        patch: operations['AgentService_updateProgram']
        trace?: never
    }
    '/.api/client-config': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['getClientConfig']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/cody/auditlog': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Returns all audit log entries as a stream of bytes, which can be consumed
         *     as a Protobuf payload. */
        get: operations['CodyAuditLog_retrieve']
        put?: never
        post?: never
        delete: operations['CodyAuditLog_delete']
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/completions/code': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Get LLM completions as a non-streaming response */
        post: operations['Completions_completions']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/completions/stream': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        /** Get streaming LLM completions with SSE */
        post: operations['Completions_chatCompletions']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/conversations': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['ConversationService_retrieveConversations']
        put?: never
        post: operations['ConversationService_createConversation']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/conversations/{conversation_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch: operations['ConversationService_updateConversation']
        trace?: never
    }
    '/.api/conversations/{conversation_id}/messages': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post: operations['ConversationService_createMessage']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/conversations/{conversation_id}/messages/{message_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch: operations['ConversationService_updateMessage']
        trace?: never
    }
    '/.api/modelconfig/supported-models.json': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['getSupportedModels']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/reviews': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description List all reviews that have been performed. */
        get: operations['ReviewService_retrieveReviews']
        put?: never
        /** @description Requests a code review of a given Git diff. Supports GitHub Pull Requests and Gitlab Merge Requests.
         *
         *     The `diff` field in the request body must be defined. */
        post: operations['ReviewService_reviewDiff']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/reviews/diagnostics/{diagnostic_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Retrieve a diagnostic by its review ID. */
        get: operations['ReviewService_retrieveDiagnostic']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/reviews/diagnostics/{diagnostic_id}/feedback': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get?: never
        put?: never
        post: operations['ReviewService_createDiagnosticFeedback']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/reviews/sessions': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description List all review sessions, which is a set of reviews executed against the same
         *     pull request or logical diff. */
        get: operations['ReviewService_retrieveReviewSessions']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/reviews/{review_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Retrieve a review by its review ID. */
        get: operations['ReviewService_retrieveReview']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/rules': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['RuleService_retrieveRules']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/rules/{rule_uri_or_slug}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        get: operations['RuleService_getRule']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/threads': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description List all threads. */
        get: operations['ThreadService_listThreads']
        put?: never
        /** @description Create a new thread. */
        post: operations['ThreadService_createThread']
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
    '/.api/threads/{thread_id}': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Get a single thread. */
        get: operations['ThreadService_getThread']
        put?: never
        post?: never
        /** @description Delete a thread. */
        delete: operations['ThreadService_deleteThread']
        options?: never
        head?: never
        /** @description Update a thread. */
        patch: operations['ThreadService_updateThread']
        trace?: never
    }
    '/.api/tools': {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        /** @description Returns a list of tools describing APIs that can be used together as
         *     building blocks for agents. */
        get: operations['ToolService_listTools']
        put?: never
        post?: never
        delete?: never
        options?: never
        head?: never
        patch?: never
        trace?: never
    }
}
export type webhooks = Record<string, never>
export interface components {
    schemas: {
        Agent: {
            /**
             * Format: int32
             * @description Unique identifier for the agent, generated by the server.
             */
            id: number
            /**
             * Format: int32
             * @description The ID of the user who created the agent.
             *
             *     Agent programs will be run as this user, and API consumption will be
             *     attributed to this user.
             */
            owner_user_id?: number | null
            /** @description The title of the agent.
             *
             *     For example, "Security Review Agent" */
            title?: string | null
            /** @description A short description describing the goals of this agent. */
            description?: string | null
            /** @description Connections with external services like GitHub and GitLab. */
            connections: components['schemas']['AgentConnection'][]
            /** @description Installed programs for this agent. */
            programs: components['schemas']['AgentProgram'][]
        }
        AgentConnection: {
            /** Format: int32 */
            id: number
            /** @enum {string} */
            type: 'github_app' | 'github_webhook' | 'gitlab_webhook'
            /** @description The name of the GitHub/GitLab app or webhook, if any.
             *
             *     Read-only; do not include when creating or updating. */
            name?: string | null
            /** @description URL to the admin page for this connection.
             *
             *     Read-only; do not include when creating or updating. */
            admin_html_url?: string | null
            github_app?: components['schemas']['AgentGitHubAppConnection'] | null
        }
        AgentGitHubAppConnection: {
            /** Format: int32 */
            github_app_id: number
            /**
             * Format: int32
             * @description The webhook ID to use for incoming events.
             *
             *     If you create a GitHub app on Sourcegraph, it will automatically create
             *     a webhook ID for you. When creating agent connections, this should be left
             *     undefined if you want to use the automatically connected webhook ID.
             *
             *     Only set this to a custom ID if you know what you are doing. For example,
             *     you manually created a webhook in the UI and want to use that over the
             *     webhook ID that is automatically connected to the GitHub app.
             */
            webhook_id?: number | null
            /** @description URL to the admin page for the webhook, if any.
             *
             *     Read-only; do not include when creating or updating. */
            webhook_admin_html_url?: string | null
        }
        /** @description An agent program is a small of code that is evaluated whenever an event happens
         *     from the agent's connections. */
        AgentProgram: {
            /** Format: int32 */
            id: number
            /**
             * @description The status of the program.
             *
             *     Null means it's not set (for example, in PATCH requests).
             * @enum {string|null}
             */
            status?: 'enabled' | 'disabled' | null
            /** @description The files that make up this program.
             *
             *     Null means it's not set, empty array means it's empty.
             *
             *     The only valid format is a single file with a .sourcegraph/review-agent.json
             *     file, which contains a ReviewRequestConfiguration. For example:
             *     ```jsonc
             *     // File: .sourcegraph/review-agent.json
             *     {
             *         "rules": ["all-inferred"],
             *         "minimum_severity": "error",
             *     }
             *     ```
             *     The minimum requirement is to have an empty object for the configuration.
             *     ```jsonc
             *     // File: .sourcegraph/review-agent.json
             *     {}
             *     ``` */
            files?: components['schemas']['AgentProgramFile'][] | null
        }
        AgentProgramFile: {
            path: string
            content: string
        }
        /** @description An agent program is a small of code that is evaluated whenever an event happens
         *     from the agent's connections. */
        AgentProgramUpdate: {
            /** Format: int32 */
            id?: number
            /**
             * @description The status of the program.
             *
             *     Null means it's not set (for example, in PATCH requests).
             * @enum {string|null}
             */
            status?: 'enabled' | 'disabled' | null
            /** @description The files that make up this program.
             *
             *     Null means it's not set, empty array means it's empty.
             *
             *     The only valid format is a single file with a .sourcegraph/review-agent.json
             *     file, which contains a ReviewRequestConfiguration. For example:
             *     ```jsonc
             *     // File: .sourcegraph/review-agent.json
             *     {
             *         "rules": ["all-inferred"],
             *         "minimum_severity": "error",
             *     }
             *     ```
             *     The minimum requirement is to have an empty object for the configuration.
             *     ```jsonc
             *     // File: .sourcegraph/review-agent.json
             *     {}
             *     ``` */
            files?: components['schemas']['AgentProgramFile'][] | null
        }
        AgentRetrieveResponse: {
            agents: components['schemas']['Agent'][]
        }
        AgentUpdate: {
            /**
             * Format: int32
             * @description Unique identifier for the agent, generated by the server.
             */
            id?: number
            /**
             * Format: int32
             * @description The ID of the user who created the agent.
             *
             *     Agent programs will be run as this user, and API consumption will be
             *     attributed to this user.
             */
            owner_user_id?: number | null
            /** @description The title of the agent.
             *
             *     For example, "Security Review Agent" */
            title?: string | null
            /** @description A short description describing the goals of this agent. */
            description?: string | null
            /** @description Connections with external services like GitHub and GitLab. */
            connections?: components['schemas']['AgentConnection'][]
            /** @description Installed programs for this agent. */
            programs?: components['schemas']['AgentProgram'][]
        }
        AssistantToolsFunction: {
            /** @enum {string} */
            type: 'function'
            function: components['schemas']['FunctionObject']
        }
        CacheControl: {
            /** @enum {string} */
            type: 'ephemeral'
        }
        /** @description This is the JSON object which all clients request after authentication to determine how
         *     they should behave, e.g. if a site admin has restricted chat/autocomplete/other functionality,
         *     if experimental features are available, etc.
         *
         *     The configuration is always specific to a single authenticated user.
         *
         *     Adding new fields here is fine, but you cannot make backwards-incompatible changes (removing
         *     fields or change the meaning of fields in backwards-incompatible ways.) If you need to do that,
         *     then read up on https://github.com/sourcegraph/sourcegraph/pull/63591#discussion_r1663211601
         *
         *     After adding a field here, you can implement it in cmd/frontend/internal/clientconfig/clientconfig.go
         *     GetForActor method. */
        ClientConfig: {
            /** @description Whether the site admin allows this user to make use of Cody at all. */
            codyEnabled: boolean
            /** @description Whether the site admin allows this user to make use of the Cody chat feature. */
            chatEnabled: boolean
            /** @description Whether the site admin allows this user to make use of the Cody autocomplete feature. */
            autoCompleteEnabled: boolean
            /** @description Whether the site admin allows the user to make use of the **custom** Cody commands feature. */
            customCommandsEnabled: boolean
            /** @description Whether the site admin allows this user to make use of the Cody attribution feature. */
            attributionEnabled: boolean
            /** @description Whether the 'smart context window' feature should be enabled, and whether the Sourcegraph
             *     instance supports various new GraphQL APIs needed to make it work. */
            smartContextWindowEnabled: boolean
            /** @description Whether the new Sourcegraph backend LLM models API endpoint should be used to query which
             *     models are available. */
            modelsAPIEnabled: boolean
            /**
             * Format: int32
             * @description The latest `api-version=N` query parameter that is supported by the
             *     `POST /.api/completions/stream` endpoint. This field was added after
             *     `api-version=2` so you will never get a response with `api-version=1` or
             *     lower even when `api-version=1` is supported on the instance.
             */
            latestSupportedCompletionsStreamAPIVersion?: number
            /** @description Whether the user should be redirected to the enterprise version of Sourcegraph from PLG, assuming they are on PLG by accident. */
            userShouldUseEnterprise?: boolean
        }
        /** @description Anything that needs to be provided to Cody clients at the model-level can go here.
         *
         *     For example, allowing the server to customize/override the LLM
         *     prompt used. Or describe how clients should upload context to
         *     remote servers, etc. Or "hints", like "this model is great when
         *     working with 'C' code.". */
        ClientSideModelConfig: {
            openAICompatible?: components['schemas']['ClientSideModelConfigOpenAICompatible'] | null
        }
        /** @description Client-side model configuration used when the model is backed by an OpenAI-compatible API
         *     provider. */
        ClientSideModelConfigOpenAICompatible: {
            /** @description (optional) List of stop sequences to use for this model. */
            stopSequences?: string[]
            /** @description (optional) EndOfText identifier used by the model. e.g. "<|endoftext|>", "< EOT >" */
            endOfText?: string
            /**
             * Format: uint32
             * @description (optional) A hint the client should use when producing context to send to the LLM.
             *     The maximum length of all context (prefix + suffix + snippets), in characters.
             */
            contextSizeHintTotalCharacters?: number | null
            /**
             * Format: uint32
             * @description (optional) A hint the client should use when producing context to send to the LLM.
             *     The maximum length of the document prefix (text before the cursor) to include, in characters.
             */
            contextSizeHintPrefixCharacters?: number | null
            /**
             * Format: uint32
             * @description (optional) A hint the client should use when producing context to send to the LLM.
             *     The maximum length of the document suffix (text after the cursor) to include, in characters.
             */
            contextSizeHintSuffixCharacters?: number | null
            /** @description (optional) Custom instruction to be included at the start of all chat messages
             *     when using this model, e.g. "Answer all questions in Spanish."
             *
             *     Note: similar to Cody client config option `cody.chat.preInstruction`; if user has
             *     configured that it will be used instead of this. */
            chatPreInstruction?: string
            /** @description (optional) Custom instruction to be included at the end of all edit commands
             *     when using this model, e.g. "Write all unit tests with Jest instead of detected framework."
             *
             *     Note: similar to Cody client config option `cody.edit.preInstruction`; if user has
             *     configured that it will be respected instead of this. */
            editPostInstruction?: string
            /**
             * Format: uint32
             * @description (optional) How long the client should wait for autocomplete results to come back (milliseconds),
             *     before giving up and not displaying an autocomplete result at all.
             *
             *     This applies on single-line completions, e.g. `var i = <completion>`
             *
             *     Note: similar to hidden Cody client config option `cody.autocomplete.advanced.timeout.singleline`
             *     If user has configured that, it will be respected instead of this.
             */
            autocompleteSinglelineTimeout?: number
            /**
             * Format: uint32
             * @description (optional) How long the client should wait for autocomplete results to come back (milliseconds),
             *     before giving up and not displaying an autocomplete result at all.
             *
             *     This applies on multi-line completions, which are based on intent-detection when e.g. a code block
             *     is being completed, e.g. `func parseURL(url string) {<completion>`
             *
             *     Note: similar to hidden Cody client config option `cody.autocomplete.advanced.timeout.multiline`
             *     If user has configured that, it will be respected instead of this.
             */
            autocompleteMultilineTimeout?: number
            /**
             * Format: double
             * @description (optional) model parameters to use for the chat feature
             */
            chatTopK?: number | null
            /** Format: double */
            chatTopP?: number | null
            /** Format: double */
            chatTemperature?: number | null
            /** Format: uint32 */
            chatMaxTokens?: number
            /**
             * Format: double
             * @description (optional) model parameters to use for the autocomplete feature
             */
            autoCompleteTopK?: number | null
            /** Format: double */
            autoCompleteTopP?: number | null
            /** Format: double */
            autoCompleteTemperature?: number | null
            /** Format: uint32 */
            autoCompleteSinglelineMaxTokens?: number
            /** Format: uint32 */
            autoCompleteMultilineMaxTokens?: number
            /**
             * Format: double
             * @description (optional) model parameters to use for the edit feature
             */
            editTopK?: number | null
            /** Format: double */
            editTopP?: number | null
            /** Format: double */
            editTemperature?: number | null
            /** Format: uint32 */
            editMaxTokens?: number
        }
        CompletionMessage: {
            /** @enum {string} */
            role: 'user' | 'assistant' | 'system'
            content: string | components['schemas']['MessageContentPart'][]
            /** @description Prompt caching.
             *
             *     This is currently only supported on messages when using Anthropic Model
             *     Claude 3.5 Sonnet, Claude 3.5 Haiku, Claude 3 Haiku, and Claude 3 Opus.
             *
             *     Note: This does not work with Anthropic on AWS Bedrock or Vertex.
             *
             *     Docs:
             *     - https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
             *     - https://docs.anthropic.com/en/api/messages */
            cache_control?: components['schemas']['CacheControl'] | null
        }
        CompletionRequest: {
            /** @description The language model to use for the completion.
             *     Call `/.api/modelconfig/supported-models.json` to get the list of available models. */
            model: string
            /** @description The messages to generate completions for.
             *     When using `/.api/completions/code`, only include one message with the speaker 'human'. */
            messages: components['schemas']['CompletionMessage'][]
            /** @description Optional list of tool function definitions supported by the assistant.
             *     There can be a maximum of 128 tools per assistant. */
            tools?: components['schemas']['AssistantToolsFunction'][] | null
            /**
             * Format: int32
             * @description The maximum number of tokens to generate before stopping.
             *     Note that our models may stop before reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.
             */
            maxTokensToSample?: number
            /**
             * Format: double
             * @description Amount of randomness injected into the response.
             *
             *     Defaults to 1.0. Ranges from 0.0 to 1.0. Use temperature closer to 0.0
             *     for analytical / multiple choice, and closer to 1.0 for creative and
             *     generative tasks.
             *
             *     Note that even with temperature of 0.0, the results will not be fully
             *     deterministic.
             */
            temperature?: number
            /** @description Sequences that will cause the model to stop generating.
             *
             *     Our models stop on "\n\nHuman:", and may include additional built-in stop
             *     sequences in the future. By providing the `stop_sequences` parameter, you may
             *     include additional strings that will cause the model to stop generating. */
            stopSequences?: string[]
            /**
             * Format: int32
             * @description Only sample from the top K options for each subsequent token.
             *
             *     Used to remove "long tail" low probability responses. Learn more technical details here:
             *     https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277
             *
             *     Recommended for advanced use cases only. You usually only need to use temperature.
             */
            topK?: number
            /**
             * Format: double
             * @description Use nucleus sampling.
             *
             *     In nucleus sampling, we compute the cumulative distribution over all the
             *     options for each subsequent token in decreasing probability order and cut it
             *     off once it reaches a particular probability specified by `top_p`. You should
             *     either alter temperature or `top_p`, but not both.
             *
             *     Recommended for advanced use cases only. You usually only need to use temperature.
             */
            topP?: number
            /** @description Whether to stream the response.
             *
             *     - When true, the response body is an SSE stream of `event: completion\ndata: JSON` where
             *     each JSON blob is a `CompletionResponse`.
             *     - When false, the response body is a single JSON-encoded `CompletionResponse`. */
            stream?: boolean | null
            /**
             * Format: uint8
             * @description Include the log probabilities on the logprobs most likely tokens, as well the chosen tokens. For example, if logprobs is 5, the API will return a list of the 5 most likely tokens. The API will always return the logprob of the sampled token, so there may be up to logprobs+1 elements in the response.
             *     The maximum value for logprobs is 5.
             *     For more details, see Fireworks API docs https://docs.fireworks.ai/api-reference/post-completions
             */
            logprobs?: number
        }
        CompletionResponse: {
            /** @description Completion is the full completion string. This field
             *     is only present when using the `/.api/completions/code` or when
             *     using `api-version=1` or older with `/.api/completions/stream`.
             *
             *     In the V2 API for streaming responses, the `deltaText` property is used
             *     instead. */
            completion?: string
            /** @description DeltaText is the incremental text that was added to the prompt.
             *     This field is only present in streaming responses to `/.api/completions/stream`. */
            deltaText?: string
            /** @description The full list of tool calls. This field is only present for non-streaming responses. */
            tool_calls?: components['schemas']['ToolCall'][] | null
            /** @description Same as `tool_calls`, but only present in streaming responses to
             *     `/.api/completions/stream`.  The semantics for this field is that the
             *     function.arguments field should be concatenated between streaming chunks,
             *     eventually forming a valid JSON object. */
            delta_tool_calls?: components['schemas']['ToolCall'][] | null
            /** @description The model used for completion.
             *     NOTE: this model may be different than the model specified in the request.
             *     Requires `api-version=5` or higher. */
            model?: string | null
            /** @description The reason the model stopped generating tokens. The exact format
             *     of this field is defined by the model provider.
             *
             *     For OpenAI models, the following stop reasons are defined:
             *     - `stop`: the model hit a natural stop point or a provided stop sequence.
             *     - `length`: the maximum number of tokens specified in the request was reached.
             *     - `content_filter`: content was omitted due content filters.
             *
             *     For Anthropic models, the following stop reasons are defined:
             *     - "stop_sequence": we reached a stop sequence either provided via the
             *     stop_sequences parameter, or a stop sequence built into the model.
             *     - "max_tokens": we exceeded max_tokens_to_sample or the model's maximum limit. */
            stopReason?: string
            /** @description Usage is the number of tokens used in the completion.
             *     Requires `api-version=5` or higher. */
            usage?: components['schemas']['CompletionUsage'] | null
            logprobs?: components['schemas']['Logprobs'] | null
        }
        /** @description Usage statistics for the completion request. */
        CompletionUsage: {
            /**
             * Format: int32
             * @description Number of tokens in the generated completion.
             */
            completion_tokens: number
            /**
             * Format: int32
             * @description Number of tokens in the prompt.
             */
            prompt_tokens: number
            /**
             * Format: int32
             * @description Total number of tokens used in the request (prompt + completion).
             */
            total_tokens: number
            /** @description Breakdown of tokens used in the prompt.
             *     Docs: https://platform.openai.com/docs/api-reference/chat/create */
            prompt_tokens_details?: components['schemas']['PromptTokensDetails'] | null
        }
        ContextWindow: {
            /** Format: int32 */
            maxInputTokens: number
            /** Format: int32 */
            maxOutputTokens: number
        }
        Conversation: {
            /** Format: int32 */
            id: number
            /** @enum {string} */
            kind: 'pull_request_review' | 'pull_request'
            /** @description The URL to the external API endpoint for this conversation.
             *
             *     Example: https://api.github.com/repos/sourcegraph/cloud/pulls/21715 */
            external_api_url?: string | null
            /** @description The URL to the external HTML endpoint for this conversation.
             *
             *     Example: https://github.com/sourcegraph/cloud/pull/21715 */
            external_html_url?: string | null
            /** Format: int32 */
            pull_request_id?: number | null
            /** Format: int64 */
            external_service_id?: number | null
            /** Format: int32 */
            agent_id?: number | null
            /** Format: int32 */
            user_id?: number | null
            /** Format: int32 */
            diagnostic_id?: number | null
            /** Format: int32 */
            review_id?: number | null
            location?: components['schemas']['Location'] | null
            /** @enum {string|null} */
            status?: 'open' | 'resolved' | null
            /** @description The messages attached to this conversation.
             *
             *     Null means it's unpopulated, and empty array means it's empty. */
            messages?: components['schemas']['ConversationMessage'][] | null
        }
        ConversationMessage: {
            /** Format: int32 */
            id: number
            /** @description The URL to the external API endpoint for this conversation.
             *
             *     Example: https://api.github.com/repos/sourcegraph/cloud/pulls/21715 */
            external_api_url?: string | null
            /** @description The URL to the external HTML endpoint for this conversation.
             *
             *     Example: https://github.com/sourcegraph/cloud/pull/21715 */
            external_html_url?: string | null
            /** Format: int64 */
            external_service_id?: number | null
            /** Format: int32 */
            conversation_id?: number | null
            /** Format: int32 */
            user_id?: number | null
            /** @enum {string|null} */
            role?: 'assistant' | 'user' | 'system' | null
            content: components['schemas']['ConversationMessageContent']
            /** @description ISO 8601 formatted DateTime. */
            created_at: string
            /** @description ISO 8601 formatted DateTime. */
            updated_at: string
        }
        ConversationMessageContent: {
            /** @enum {string} */
            type: 'text' | 'json'
            text?: string | null
            json?: unknown
        }
        ConversationMessageContentUpdate: {
            /** @enum {string} */
            type?: 'text' | 'json'
            text?: string | null
            json?: unknown
        }
        ConversationMessageUpdate: {
            /** Format: int32 */
            id?: number
            /** @description The URL to the external API endpoint for this conversation.
             *
             *     Example: https://api.github.com/repos/sourcegraph/cloud/pulls/21715 */
            external_api_url?: string | null
            /** @description The URL to the external HTML endpoint for this conversation.
             *
             *     Example: https://github.com/sourcegraph/cloud/pull/21715 */
            external_html_url?: string | null
            /** Format: int64 */
            external_service_id?: number | null
            /** Format: int32 */
            conversation_id?: number | null
            /** Format: int32 */
            user_id?: number | null
            /** @enum {string|null} */
            role?: 'assistant' | 'user' | 'system' | null
            content?: components['schemas']['ConversationMessageContentUpdate']
            /** @description ISO 8601 formatted DateTime. */
            created_at?: string
            /** @description ISO 8601 formatted DateTime. */
            updated_at?: string
        }
        ConversationRetrieveResponse: {
            links?: components['schemas']['Links'] | null
            conversations: components['schemas']['Conversation'][]
        }
        ConversationUpdate: {
            /** Format: int32 */
            id?: number
            /** @enum {string} */
            kind?: 'pull_request_review' | 'pull_request'
            /** @description The URL to the external API endpoint for this conversation.
             *
             *     Example: https://api.github.com/repos/sourcegraph/cloud/pulls/21715 */
            external_api_url?: string | null
            /** @description The URL to the external HTML endpoint for this conversation.
             *
             *     Example: https://github.com/sourcegraph/cloud/pull/21715 */
            external_html_url?: string | null
            /** Format: int32 */
            pull_request_id?: number | null
            /** Format: int64 */
            external_service_id?: number | null
            /** Format: int32 */
            agent_id?: number | null
            /** Format: int32 */
            user_id?: number | null
            /** Format: int32 */
            diagnostic_id?: number | null
            /** Format: int32 */
            review_id?: number | null
            location?: components['schemas']['LocationUpdate'] | null
            /** @enum {string|null} */
            status?: 'open' | 'resolved' | null
            /** @description The messages attached to this conversation.
             *
             *     Null means it's unpopulated, and empty array means it's empty. */
            messages?: components['schemas']['ConversationMessage'][] | null
        }
        DefaultModels: {
            chat: string
            fastChat: string
            codeCompletion: string
        }
        Email: {
            email_address: string
            is_primary: boolean
            is_verified: boolean
        }
        FilePart: {
            /** @enum {string} */
            type: 'file'
            file: {
                uri: string
                language_id?: string
                content?: string
            }
        } & (Omit<WithRequired<components['schemas']['MessageContentPart'], 'type'>, 'type'> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: 'file'
        })
        FunctionObject: {
            /** @description The name of the function to be called. Must be a-z, A-Z, 0-9, or
             *     contain underscores and dashes, with a maximum length of 64. */
            name: string
            /** @description A description of what the function does, used by the model to
             *     choose when and how to call the function. */
            description?: string
            /** @description Whether to enable strict schema adherence when generating the
             *     function call. If set to true, the model will follow the exact
             *     schema defined in the `parameters` field. Only a subset of JSON
             *     Schema is supported when `strict` is `true`. */
            strict?: boolean | null
            /** @description The parameters the functions accepts, described as a JSON Schema object.
             *     See the guide for examples, and the JSON Schema reference for documentation
             *     about the format.
             *
             *     Omitting `parameters` defines a function with an empty parameter list. */
            parameters?: {
                [key: string]: unknown
            }
        }
        /** @description Utility model for the commonly reused include/exclude glob patterns.
         *
         *     The longest regexp takes precedence. For example, `include: ["src/"]` and
         *     `exclude: ["src/main.go"]` will include all files in the `src/` directory
         *     except `src/main.go`. The same precedence rules applies the other way around,
         *     so `include: ["**", "src/main.go"]` and `exclude: ["src/"]` will include everything
         *     unless it's in the `src/` directory and isn't `src/main.go`. */
        GlobFilters: {
            /** @description List of glob patterns to include. An empty list indicates everything
             *     matches.
             *
             *     **Negative patterns**
             *     A glob starting with `!` is a negative pattern that is interpreted the
             *     same as `exclude: [pattern[1:]]`. Nested negative patterns are not
             *     supported. */
            include?: string[]
            /** @description List of glob patterns to exclude. An empty list indicates everything
             *     matches.
             *
             *     **Negative patterns**
             *     A glob starting with `!` is a negative pattern that is interpreted the
             *     same as `include: [pattern[1:]]`. Nested negative patterns are not
             *     supported. */
            exclude?: string[]
        }
        ImagePart: {
            /** @enum {string} */
            type: 'image_url'
            image_url: {
                url: string
                /** @enum {string} */
                detail?: 'low' | 'high' | 'auto'
            }
        } & (Omit<WithRequired<components['schemas']['MessageContentPart'], 'type'>, 'type'> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: 'image_url'
        })
        Links: {
            self: string
            first: string | null
            last: string | null
            next: string | null
            prev: string | null
        }
        ListToolsResponse: {
            tools: components['schemas']['ToolInformation'][]
        }
        /** @description A location in a source file. */
        Location: {
            /** @description The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'. */
            repo: string
            /** @description The path relative to the git root. */
            path: string
            /** @description The Git object ID (SHA) of the file. */
            oid: string
            /** @description (optional) The Git reference (branch or tag) to use.  Useful to track the
             *     position when the oid is lost, for example due to a force push. The ref
             *     may also get lost, for example `/refs/pull/N/head` can be deleted after
             *     the pull request N is closed. */
            ref?: string | null
            /** @description (optional) A source position in this path. */
            range?: components['schemas']['Range'] | null
        }
        /** @description A location in a source file. */
        LocationUpdate: {
            /** @description The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'. */
            repo?: string
            /** @description The path relative to the git root. */
            path?: string
            /** @description The Git object ID (SHA) of the file. */
            oid?: string
            /** @description (optional) The Git reference (branch or tag) to use.  Useful to track the
             *     position when the oid is lost, for example due to a force push. The ref
             *     may also get lost, for example `/refs/pull/N/head` can be deleted after
             *     the pull request N is closed. */
            ref?: string | null
            /** @description (optional) A source position in this path. */
            range?: components['schemas']['RangeUpdate'] | null
        }
        Logprobs: {
            tokens: string[]
            token_logprobs: number[]
            top_logprobs: {
                [key: string]: number
            }[]
            text_offset: number[]
        }
        MessageContentPart: {
            type: string
        }
        Model: {
            modelRef: string
            displayName: string
            modelName: string
            capabilities: components['schemas']['ModelCapability'][]
            category: components['schemas']['ModelCategory']
            status: components['schemas']['ModelStatus']
            tier: components['schemas']['ModelTier']
            contextWindow: components['schemas']['ContextWindow']
            clientSideConfig?: components['schemas']['ClientSideModelConfig'] | null
            estimatedModelCost?: components['schemas']['ModelCost'] | null
        }
        /** @enum {string} */
        ModelCapability: 'autocomplete' | 'chat'
        ModelCatalog: {
            schemaVersion: string
            revision: string
            providers: components['schemas']['Provider'][]
            models: components['schemas']['Model'][]
            defaultModels: components['schemas']['DefaultModels']
        }
        /** @enum {string} */
        ModelCategory: 'balanced' | 'speed' | 'other' | 'accuracy'
        ModelCost: {
            /** @enum {string} */
            unit: 'mtok' | 'btok'
            /** Format: int32 */
            inputTokenPennies: number
            /** Format: int32 */
            outputTokenPennies: number
        }
        /** @enum {string} */
        ModelStatus: 'experimental' | 'beta' | 'stable' | 'deprecated'
        /** @enum {string} */
        ModelTier: 'free' | 'pro' | 'enterprise'
        ModelUsage: {
            /** @description The reference to the model used in the review. */
            model?: string | null
            /** @description The number of tokens used by this model. */
            usage?: components['schemas']['CompletionUsage'] | null
        }
        Position: {
            /**
             * Format: int32
             * @description 0-based number within the file.
             */
            line: number
            /**
             * Format: int32
             * @description UTF-16 code unit position in the file.
             */
            character?: number | null
        }
        PositionUpdate: {
            /**
             * Format: int32
             * @description 0-based number within the file.
             */
            line?: number
            /**
             * Format: int32
             * @description UTF-16 code unit position in the file.
             */
            character?: number | null
        }
        PromptTokensDetails: {
            /**
             * Format: int32
             * @description Cached tokens present in the prompt.
             *     Equivalent to Anthropic's cache_read_input_tokens
             */
            cached_tokens?: number | null
            /**
             * Format: int32
             * @description Number of tokens written to the cache when creating a new entry.
             *     Note: this field is only set when using Anthropic as an LLM Provider.
             */
            cache_creation_input_tokens?: number | null
        }
        Provider: {
            id: string
            displayName: string
        }
        Range: {
            /** @description The range's start position. */
            start?: components['schemas']['Position'] | null
            /** @description The range's end position. */
            end?: components['schemas']['Position'] | null
        }
        RangeUpdate: {
            /** @description The range's start position. */
            start?: components['schemas']['PositionUpdate'] | null
            /** @description The range's end position. */
            end?: components['schemas']['PositionUpdate'] | null
        }
        RepoPart: {
            /** @enum {string} */
            type: 'repo'
            repo: {
                id?: string
                name?: string
                filePatterns?: string[]
            }
        } & (Omit<WithRequired<components['schemas']['MessageContentPart'], 'type'>, 'type'> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: 'repo'
        })
        /** @description Information about the repository. */
        RepositoryInfo: {
            /** @description The repository ID, which is stable even if the repository name changes. */
            id: string
            /** @description The repository name. */
            name: string
        }
        Review: {
            /**
             * Format: int32
             * @description The unique ID for this review reponse. Used to track quality metrics
             *     such as the precision/recall of a review rule.
             */
            review_id: number
            /** @description The request that triggered this review. */
            request?: components['schemas']['ReviewRequest'] | null
            /**
             * Format: int64
             * @description The database ID of the repository.
             */
            repo_id?: number | null
            /** Format: int64 */
            pull_request_synchronization_id?: number | null
            /** @description The OID of the base revision where the diff was computed from. */
            base_oid?: string | null
            /** @description The OID of the head revision where the diff was computed from. */
            head_oid?: string | null
            /** @description The rule URIs that were applied to this review.
             *
             *     Rules from the request are not automatically applied because rules can
             *     declare filters like "only trigger for TypeScript changes". */
            rules_applied?: string[] | null
            /**
             * Format: int32
             * @description The duration of the review in milliseconds.
             */
            review_duration_ms?: number | null
            /** @description The number of tokens used by this review request grouped by models. */
            model_usages?: components['schemas']['ModelUsage'][] | null
            /** @description The diagnostics returned by the review rules.
             *
             *     Note: the rule URIs in the diagnostics list are not guaranteed to match
             *     the provided rules in the list. It's the client's responsibility to decide
             *     what to do with invalid diagnostics. */
            diagnostics?: components['schemas']['ReviewDiagnostic'][] | null
            /** @description ISO 8601 formatted DateTime. */
            created_at: string
            /** @description ISO 8601 formatted DateTime. */
            updated_at: string
        }
        ReviewDiagnostic: {
            /**
             * Format: int32
             * @description A unique ID for this diagnostic, which can be used to track quality
             *     metrics such as the precision/recall of a review rule.
             */
            diagnostic_id: number
            /**
             * Format: int32
             * @description The ID of the review that produced this diagnostic.
             */
            review_id: number
            /** @description The URI of the rule that produced this comment.
             *
             *     TODO(sqs): rename to rule_uri and store the rule's URI not display_name here */
            rule_id: string
            /**
             * @description The severity of the comment, allowing the client to optionally skip
             *     displaying low-severity comments like warnings of infos.
             * @enum {string}
             */
            severity: 'error' | 'warning' | 'info'
            /** @description What code location does the diagnostic apply to? */
            location: components['schemas']['Location']
            /** @description The main message of the review comment. */
            message: string
        }
        ReviewDiagnosticEvaluationAuthor: {
            /** @enum {string} */
            type: 'user' | 'llm_judge'
            user_id?: string | null
            llm_judge?: string | null
        }
        ReviewDiagnosticFeedback: {
            /** Format: int32 */
            id?: number | null
            /** Format: int32 */
            review_id: number
            /** Format: int32 */
            diagnostic_id?: number | null
            /** @enum {string|null} */
            confusion_label?:
                | 'true-positive'
                | 'false-positive'
                | 'true-negative'
                | 'false-negative'
                | null
            /** @enum {string|null} */
            helpfulness_label?:
                | 'strongly-agree'
                | 'agree'
                | 'neutral'
                | 'disagree'
                | 'strongly-disagree'
                | null
            conversation_id?: string | null
            author?: components['schemas']['ReviewDiagnosticEvaluationAuthor'] | null
            /** @description ISO 8601 formatted DateTime. */
            created_at: string
            /** @description ISO 8601 formatted DateTime. */
            updated_at: string
        }
        ReviewDiff: {
            /** @description The repository name as it appears in Sourcegraph. For example, the GitHub
             *     repository sourcegraph/cody has the repo name "github.com/sourcegraph/cody". */
            repo: string
            /** @description The branch, tag, or commit to diff against.
             *
             *     For GitHub Pull Requests with number 100, use the revision: "refs/pull/100/head"
             *     For Gitlab Merge Request with number 200, use the revision: "refs/merge-requests/200/head" */
            head: string
            /** @description (optional) The base revision to diff against.  If omitted, diff against
             *     the merge base between the head and the default branch of the repository.
             *
             *     Explanation: merge base is the best common ancestor(s) between two
             *     commits to use in a three-way merge. */
            base?: string | null
            /** @description (optional) The inline unified diff to review.
             *     When provided, the agent will parse this with sourcegraph/go-diff, instead of
             *     reading the diff from the remote repository. */
            inline_unified_diff?: string | null
            /**
             * Format: int32
             * @description (optional) The number of context lines to include in the diff.  A larger
             *     number means more unmodified code is included in the diff, which can have
             *     pros (better understanding of the codebase) and cons (more noise, slower
             *     response).
             * @default 5
             */
            context_line_count: number
            /** @description (optional) The API URL of the pull request. When provided, the agent
             *     will only review the delta between the last agent review of the same PR. */
            pull_request_api_url?: string | null
            /** @description (optional) Only trigger for certain file paths or exclude for certain file paths.
             *
             *     For example, `paths: {include: ["src/main/"], exclude: ["Main.java"]}`
             *     will trigger for file paths that match the `src/main/` directory, but not
             *     files matching the name `"Main.java"`. */
            path_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain repositories or exclude for certain repositories.
             *
             *     For example, `repos: {include: ["github.com/sourcegraph/cody"]}` will trigger
             *     for Cody, and `repos: {exclude: ["github.com/sourcegraph/cody"]}` will trigger
             *     for all repos except Cody. */
            repo_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain languages or exclude for certain languages.
             *
             *     For example, `languages: {include: ["typescript"]}` will trigger for
             *     files containing TypeScript source code regardless if it's written in
             *     `*.ts` or `*.tsx` files. */
            language_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain file contents or exclude for certain file contents.
             *
             *     For example, `content: {include: ["fmt.Println"]}` will trigger on files
             *     containing the string "fmt.Println", and `content: {exclude: ["// ignore:go-style"]}` will trigger on
             *     files not containing the string "// ignore:go-style". */
            text_content_filters?: components['schemas']['GlobFilters']
        }
        ReviewRequest: {
            config?: components['schemas']['ReviewRequestConfiguration'] | null
            diff?: components['schemas']['ReviewDiff'] | null
        }
        ReviewRequestConfiguration: {
            /** @description List of review rules to run for this request.
             *     - Use URLs to the Sourcegraph instance to reference *.rule.md files from
             *     any repository. For example:
             *     "https://sourcegraph.sourcegraph.com/github.com/sourcegraph/cody/blob/main/rules/agent.rule.md"
             *     - Use the value "all-inferred" to run all inferred rules based on the
             *     changed files in the diff. A rule is inferred if it has the file path
             *     "*.rule.md" anywhere under a `.sourcegraph/` directory that is a parent
             *     of changed files.
             *
             *     A *.rule.md file must be formatted as a valid Markdown file with an optional frontmatter
             *     block containing YAML configuration. Example:
             *     ```
             *     ---
             *     title: "Mixed CSS Colors"
             *     description: "Prevents yellow and blue colors from being used in the same CSS file."
             *     tags: ["webdesign"]
             *     lang: "css"
             *     ---
             *     When there is yellow and blue color in the code, report an error.
             *     ```
             *
             *     The request errors if `rules` is empty and `custom_inline_rules` is also empty.
             *
             *     The GitHub App to review Pull Requests defaults rules to `["all-inferred"]`.
             *     You can override those defaults with the agent program file `.sourcegraph/review-agent.json`. */
            rules: string[]
            /**
             * @description (optional) The style of code review to perform.
             *
             *     - "default": use the default code review style. At this moment, "high-bar"
             *     is the default.
             *     - "high-bar": optimize for precision over recall. Identify and report
             *     only the most important issues and minimize false posivites like nitpick
             *     comments.
             *     - "balanced": optimize for a balance between precision and recall.  It's
             *     OK to report lower-severity issues like calling out code style
             *     improvements.
             *     - "custom:...": define a custom code review style.
             * @default default
             * @enum {string|null}
             */
            review_style: 'default' | 'high-bar' | 'balanced' | 'custom:...'
            /** @description (optional) list of custom rules to run with this request. */
            custom_inline_rules?: components['schemas']['Rule'][] | null
            /** @description (optional) The model to use for this rule. If not specified, a default
             *     model is used that strikes a balance between quality, performance, and cost. */
            preferred_model?: string | null
            /**
             * @description (optional) The minimum severity of diagnostics to include in the review.
             * @default warning
             * @enum {string|null}
             */
            minimum_severity: 'error' | 'warning' | 'info'
            /** @description (optional) Additional context to include in the review. For example,
             *     you can provide the pull request title and description with the value:
             *     ```json
             *     {
             *       "pr_title": "Add a new feature",
             *       "pr_description": "This PR adds a new feature to the application."
             *     }
             *     ``` */
            additional_context?: {
                [key: string]: string
            } | null
        }
        ReviewRetrieveResponse: {
            links?: components['schemas']['Links'] | null
            reviews: components['schemas']['Review'][]
        }
        ReviewSession: {
            runs: components['schemas']['Review'][]
            latest_run: components['schemas']['Review'] | null
            subject: components['schemas']['ReviewSubject']
        }
        ReviewSessionListResponse: {
            review_sessions: components['schemas']['ReviewSession'][]
        }
        ReviewSubject: {
            repository: components['schemas']['RepositoryInfo']
        }
        Rule: {
            /** @description A URI that refers to the rule.
             *
             *     Only 2 kinds of URIs are supported right now:
             *
             *     - URLs to files on the current Sourcegraph instance, such as
             *     `https://sourcegraph.example.com/my/repo/-/blob/foo/bar.rule.md`.
             *     - `inline:some-rule-identifier` for inline rules.
             *
             *     In the future, more types of URIs may be supported.
             *
             *     The URI is not a stable reference to the same content. The content at the location may change
             *     over time, such as when the contents of the referenced file changes.
             *
             *     TODO(sqs): It is not currently defined whether the URL to a rule file must, should, nor must
             *     not include the branch that the rule was read from. */
            uri: string
            /** @description A lossless-compressed representation of the rule's URI. This is nicer than the URI to use in
             *     URL path components for routes that, e.g., refer to a specific rule. It can
             *     be used to retrieve the rule in the same way that the URI can be used. Callers must treat
             *     this value as opaque.
             *
             *     Example: for rules on the current Sourcegraph instance, the slug is of the form
             *     "123-myrule" where 123 is the repository ID. */
            slug: string
            /** @description Logical parts of a rule URI, for display in UI breadcrumbs. */
            uri_display_parts?: components['schemas']['RuleURIDisplayParts'] | null
            /** @description The location of the rule's definition. */
            source: components['schemas']['RuleSource']
            /** @description The name of the rule, for display. It is not guaranteed to be unique.
             *
             *     By convention:
             *
             *     - For rule files, this is the relative path after `.sourcegraph/` up to `.rule.md`. For
             *     example, `.sourcegraph/a/b.rule.md` has a display name of `a/b`. If the `.sourcegraph/`
             *     directory is not at the root of the repository, the display name is prefixed with its
             *     subdirectory.
             *     - For inline rule, this is the URI without the `inline:` URI scheme. */
            display_name: string
            /** @description The title of the rule. If not set, use `display_name` instead. */
            title?: string | null
            /** @description A short description of the rule. */
            description?: string | null
            /** @description A natural-language definition of the rule. */
            instruction?: string | null
            /** @description (optional) Tags to categorize the rule. Useful if you want to organize a large set of rules. */
            tags?: string[] | null
            /** @description (optional) Only trigger for certain file paths or exclude for certain file paths.
             *
             *     For example, `paths: {include: ["src/main/"], exclude: ["Main.java"]}`
             *     will trigger for file paths that match the `src/main/` directory, but not
             *     files matching the name `"Main.java"`. */
            path_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain repositories or exclude for certain repositories.
             *
             *     For example, `repos: {include: ["github.com/sourcegraph/cody"]}` will trigger
             *     for Cody, and `repos: {exclude: ["github.com/sourcegraph/cody"]}` will trigger
             *     for all repos except Cody. */
            repo_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain languages or exclude for certain languages.
             *
             *     For example, `languages: {include: ["typescript"]}` will trigger for
             *     files containing TypeScript source code regardless if it's written in
             *     `*.ts` or `*.tsx` files. */
            language_filters?: components['schemas']['GlobFilters']
            /** @description (optional) Only trigger for certain file contents or exclude for certain file contents.
             *
             *     For example, `content: {include: ["fmt.Println"]}` will trigger on files
             *     containing the string "fmt.Println", and `content: {exclude: ["// ignore:go-style"]}` will trigger on
             *     files not containing the string "// ignore:go-style". */
            text_content_filters?: components['schemas']['GlobFilters']
            /** @description The raw content of the rule's definition (in the original Markdown). */
            raw_content?: string | null
        }
        RuleRetrieveResponse: {
            links?: components['schemas']['Links'] | null
            rules: components['schemas']['Rule'][]
        }
        /** @description The source of a rule. Exactly one field must be set.
         *
         *     TODO(sqs): This is intended to be a `union` not `model`, but our Go codegen does not support unions yet. */
        RuleSource: {
            repository?: components['schemas']['RuleSourceRepository']
            /** @enum {boolean} */
            inline?: true
        }
        RuleSourceRepository: {
            /** @enum {string} */
            type: 'repo'
            /** @description The template for omitting properties. */
            location: {
                /** @description The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'. */
                repo: string
                /** @description The path relative to the git root. */
                path: string
                /** @description The Git object ID (SHA) of the file. */
                oid: string
                /** @description (optional) The Git reference (branch or tag) to use.  Useful to track the
                 *     position when the oid is lost, for example due to a force push. The ref
                 *     may also get lost, for example `/refs/pull/N/head` can be deleted after
                 *     the pull request N is closed. */
                ref?: string | null
            }
        }
        /** @description Logical parts of a rule URI, extracted for display in UI breadcrumbs. */
        RuleURIDisplayParts: {
            /** @enum {string} */
            source_label: 'inline' | 'repo'
            /** @description The name of the repository that contains this rule. The branch is implied in the name but is
             *            concretely resolved in the `Rule.source` field. */
            repo?: string | null
            /** @description The subpath within a repository to the `.sourcegraph` or `.config/sourcegraph` directory that
             *     contains this rule.
             *
             *     Examples:
             *     - `.sourcegraph/a.rule.md`: null
             *     - `subproj/.sourcegraph/b/c.rule.md`: `subproj` */
            group_path?: string | null
            /** @description The relative path and name within the group directory to the rule.
             *
             *     Examples:
             *     - `.sourcegraph/a.rule.md`: `a`
             *     - `subproj/.sourcegraph/b/c.rule.md`: `b/c` */
            name_path?: string | null
        }
        TextPart: {
            /** @enum {string} */
            type: 'text'
            text?: string
        } & (Omit<WithRequired<components['schemas']['MessageContentPart'], 'type'>, 'type'> & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: 'text'
        })
        /** @description A chat thread. */
        Thread: {
            /**
             * Format: int32
             * @description The unique ID for this thread.
             */
            id: number
            /** @description The title of the thread (if any). */
            title: string | null
            /** @description The user who created this thread. */
            creator: components['schemas']['User']
            /** @description The thread visibility settings. */
            visibility: components['schemas']['ThreadVisibility']
            /** @description JSON data for the thread. */
            data?: unknown
            /** @description Raw text content of messages in the thread. This is derived from the `data` field and is used
             *     as a fallback when the server does not know how to parse `data` (for data in older schemas,
             *     for example). */
            messages_raw_text?: string | null
            /**
             * Format: date-time
             * @description When this thread was created.
             */
            created_at: string
            /**
             * Format: date-time
             * @description When this thread was last updated.
             */
            updated_at: string
        }
        /** @description Initial data to create a thread. */
        ThreadCreate: {
            /** @description The title of the thread. */
            title?: string | null
            /** @description The thread visibility settings. */
            visibility?: components['schemas']['ThreadVisibility'] | null
            /** @description JSON data for the thread. */
            data?: unknown
            /** @description The raw text content of messages in the thread. */
            messages_raw_text?: string | null
        }
        ThreadListResponse: {
            links?: components['schemas']['Links'] | null
            threads: components['schemas']['Thread'][]
        }
        /** @description An update to a thread. */
        ThreadUpdate: {
            /** @description The new title of the thread. */
            title?: string | null
            /** @description The new thread visibility settings. */
            visibility?: components['schemas']['ThreadVisibilityUpdate'] | null
            /** @description The new JSON data for the thread. */
            data?: unknown
            /** @description The new raw text content of messages in the thread. */
            messages_raw_text?: string | null
        }
        /** @description Visibility settings for a thread. */
        ThreadVisibility: {
            /** @description Whether this thread is accessible to any authenticated user on the instance who has the link. */
            link: boolean
        }
        /** @description Visibility settings for a thread. */
        ThreadVisibilityUpdate: {
            /** @description Whether this thread is accessible to any authenticated user on the instance who has the link. */
            link?: boolean
        }
        ToolCall: {
            /** @description The ID of the tool call. */
            id: string
            /**
             * @description The type of the tool. Currently, only `function` is supported.
             * @enum {string}
             */
            type: 'function'
            /** @description The function that the model called. */
            function: components['schemas']['ToolCallFunction']
        }
        ToolCallFunction: {
            /** @description The name of the function to call. */
            name: string
            /** @description The arguments to call the function with, as generated by the model in JSON format.
             *     Note that the model does not always generate valid JSON, and may hallucinate parameters
             *     not defined by your function schema. Validate the arguments in your code before
             *     calling your function. */
            arguments: string
        }
        ToolInformation: {
            request_path: string
            function: components['schemas']['FunctionObject']
            return_type: {
                [key: string]: unknown
            }
        }
        User: {
            id: string
            /** Format: int64 */
            database_id: number
            username: string
            avatar_url: string
            display_name: string
            url: string
            emails: components['schemas']['Email'][]
        }
    }
    responses: never
    parameters: never
    requestBodies: never
    headers: never
    pathItems: never
}
export type $defs = Record<string, never>
export interface operations {
    AgentService_retrieveAgents: {
        parameters: {
            query?: {
                'page[number]'?: number
                'page[size]'?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AgentRetrieveResponse']
                }
            }
        }
    }
    AgentService_createAgent: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['Agent']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Agent']
                }
            }
        }
    }
    AgentService_retrieveAgent: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Agent']
                }
            }
        }
    }
    AgentService_removeAgent: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Agent']
                }
            }
        }
    }
    AgentService_updateAgent: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AgentUpdate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Agent']
                }
            }
        }
    }
    AgentService_createConnection: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AgentConnection']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AgentConnection']
                }
            }
        }
    }
    AgentService_removeConnection: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
                connection_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description There is no content to send for this request, but the headers may be useful.  */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    AgentService_createProgram: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AgentProgram']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AgentProgram']
                }
            }
        }
    }
    AgentService_removeProgram: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
                program_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description There is no content to send for this request, but the headers may be useful.  */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    AgentService_updateProgram: {
        parameters: {
            query?: never
            header?: never
            path: {
                agent_id: string
                program_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['AgentProgramUpdate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['AgentProgram']
                }
            }
        }
    }
    getClientConfig: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ClientConfig']
                }
            }
        }
    }
    CodyAuditLog_retrieve: {
        parameters: {
            query?: {
                before?: string
                after?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': string
                }
            }
        }
    }
    CodyAuditLog_delete: {
        parameters: {
            query?: {
                before?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description There is no content to send for this request, but the headers may be useful.  */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    Completions_completions: {
        parameters: {
            query?: {
                /** @description ## API Versioning
                 *
                 *     **v1**. Added support for system prompts. Uses `'completion'` property for
                 *     streaming responses.
                 *
                 *     **v2**. Added support for incremental streaming responses. Uses `'deltaText'`
                 *     instead of `'completion'` property.
                 *
                 *     **v3**. Added support for vision. Concrete changes
                 *
                 *     - The `Message.content` property now supports the union
                 *     `string | MessageContentPart[]` encoding instead of just `string`.
                 *     With `MessageContentPart[]`, you can now include images via `ImageMessageContentPart`.
                 *     - The property `Message.speaker = "human" | "assistant" | "system"` is now
                 *     replaced with `Message.role = "user" | "assistant" | "system"` for improved
                 *     compatibility with OpenAI clients. The old speaker:human syntax is still supported.
                 *     - The `Message.text` property is replaced with `Message.content`
                 *     for consistency with OpenAI clients.  The old `Message.text` property is still
                 *     supported for backwards compatibility.
                 *
                 *     **v4**. Added support for file and repo context items.
                 *
                 *     **v5**. Added token usage tracking to the response.
                 *
                 *     **v6**. Added support for tools (aka. function calling).
                 *
                 *     **v7**. Added support for Anthropic prompt caching on messages. */
                'api-version'?: 1 | 2 | 3 | 4 | 5 | 6 | 7
                /** @description The name of the application sending this request. For example, "cody-web" or "jetbrains". */
                'client-name'?: string
                /** @description The version of the application sending this request. For example, "2.0.0". */
                'client-version'?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CompletionRequest']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CompletionResponse']
                }
            }
        }
    }
    Completions_chatCompletions: {
        parameters: {
            query?: {
                /** @description ## API Versioning
                 *
                 *     **v1**. Added support for system prompts. Uses `'completion'` property for
                 *     streaming responses.
                 *
                 *     **v2**. Added support for incremental streaming responses. Uses `'deltaText'`
                 *     instead of `'completion'` property.
                 *
                 *     **v3**. Added support for vision. Concrete changes
                 *
                 *     - The `Message.content` property now supports the union
                 *     `string | MessageContentPart[]` encoding instead of just `string`.
                 *     With `MessageContentPart[]`, you can now include images via `ImageMessageContentPart`.
                 *     - The property `Message.speaker = "human" | "assistant" | "system"` is now
                 *     replaced with `Message.role = "user" | "assistant" | "system"` for improved
                 *     compatibility with OpenAI clients. The old speaker:human syntax is still supported.
                 *     - The `Message.text` property is replaced with `Message.content`
                 *     for consistency with OpenAI clients.  The old `Message.text` property is still
                 *     supported for backwards compatibility.
                 *
                 *     **v4**. Added support for file and repo context items.
                 *
                 *     **v5**. Added token usage tracking to the response.
                 *
                 *     **v6**. Added support for tools (aka. function calling).
                 *
                 *     **v7**. Added support for Anthropic prompt caching on messages. */
                'api-version'?: 1 | 2 | 3 | 4 | 5 | 6 | 7
                /** @description The name of the application sending this request. For example, "cody-web" or "jetbrains". */
                'client-name'?: string
                /** @description The version of the application sending this request. For example, "2.0.0". */
                'client-version'?: string
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CompletionRequest']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['CompletionResponse']
                }
            }
        }
    }
    ConversationService_retrieveConversations: {
        parameters: {
            query?: {
                'filter[kind]'?: 'pull_request_review' | 'pull_request'
                'filter[agent_id]'?: number | null
                'filter[user_id]'?: number | null
                'filter[diagnostic_id]'?: number | null
                'filter[review_id]'?: number | null
                'filter[pull_request_id]'?: number | null
                include?: 'messages' | null
                'page[first]'?: number
                'page[after]'?: number
                sort?: 'created_at' | '-created_at' | 'id' | '-id' | null
                'messages.page[first]'?: number
                'messages.page[after]'?: number
                'messages.sort'?: 'created_at' | '-created_at' | 'id' | '-id' | null
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ConversationRetrieveResponse']
                }
            }
        }
    }
    ConversationService_createConversation: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['Conversation']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Conversation']
                }
            }
        }
    }
    ConversationService_updateConversation: {
        parameters: {
            query?: never
            header?: never
            path: {
                conversation_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ConversationUpdate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Conversation']
                }
            }
        }
    }
    ConversationService_createMessage: {
        parameters: {
            query?: never
            header?: never
            path: {
                conversation_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ConversationMessage']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ConversationMessage']
                }
            }
        }
    }
    ConversationService_updateMessage: {
        parameters: {
            query?: never
            header?: never
            path: {
                conversation_id: string
                message_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ConversationMessageUpdate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ConversationMessage']
                }
            }
        }
    }
    getSupportedModels: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ModelCatalog']
                }
            }
        }
    }
    ReviewService_retrieveReviews: {
        parameters: {
            query?: {
                'filter[pull_request_api_url]'?: string | null
                include?: 'diagnostics' | null
                'page[number]'?: number
                'page[size]'?: number
                sort?: 'created_at' | '-created_at' | 'id' | '-id' | null
                'diagnostics.page[number]'?: number
                'diagnostics.page[size]'?: number
                'diagnostics.sort'?: 'created_at' | '-created_at' | 'id' | '-id' | null
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ReviewRetrieveResponse']
                }
            }
        }
    }
    ReviewService_reviewDiff: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ReviewRequest']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Review']
                }
            }
        }
    }
    ReviewService_retrieveDiagnostic: {
        parameters: {
            query?: never
            header?: never
            path: {
                diagnostic_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ReviewDiagnostic']
                }
            }
        }
    }
    ReviewService_createDiagnosticFeedback: {
        parameters: {
            query?: never
            header?: never
            path: {
                diagnostic_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ReviewDiagnosticFeedback']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ReviewDiagnosticFeedback']
                }
            }
        }
    }
    ReviewService_retrieveReviewSessions: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ReviewSessionListResponse']
                }
            }
        }
    }
    ReviewService_retrieveReview: {
        parameters: {
            query?: never
            header?: never
            path: {
                review_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Review']
                }
            }
        }
    }
    RuleService_retrieveRules: {
        parameters: {
            query?: {
                'filter[applies_to_repo]'?: string | null
                'filter[applies_to_rev]'?: string | null
                'filter[applies_to_path]'?: string | null
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['RuleRetrieveResponse']
                }
            }
        }
    }
    RuleService_getRule: {
        parameters: {
            query?: never
            header?: never
            path: {
                rule_uri_or_slug: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Rule']
                }
            }
        }
    }
    ThreadService_listThreads: {
        parameters: {
            query?: {
                'filter[creator_user_id]'?: number
                'page[number]'?: number
                'page[size]'?: number
            }
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ThreadListResponse']
                }
            }
        }
    }
    ThreadService_createThread: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ThreadCreate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Thread']
                }
            }
        }
    }
    ThreadService_getThread: {
        parameters: {
            query?: never
            header?: never
            path: {
                thread_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Thread']
                }
            }
        }
    }
    ThreadService_deleteThread: {
        parameters: {
            query?: never
            header?: never
            path: {
                thread_id: string
            }
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description There is no content to send for this request, but the headers may be useful.  */
            204: {
                headers: {
                    [name: string]: unknown
                }
                content?: never
            }
        }
    }
    ThreadService_updateThread: {
        parameters: {
            query?: never
            header?: never
            path: {
                thread_id: string
            }
            cookie?: never
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['ThreadUpdate']
            }
        }
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['Thread']
                }
            }
        }
    }
    ToolService_listTools: {
        parameters: {
            query?: never
            header?: never
            path?: never
            cookie?: never
        }
        requestBody?: never
        responses: {
            /** @description The request has succeeded. */
            200: {
                headers: {
                    [name: string]: unknown
                }
                content: {
                    'application/json': components['schemas']['ListToolsResponse']
                }
            }
        }
    }
}
type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P]
}
